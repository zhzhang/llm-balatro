---
import BaseHead from '../components/BaseHead.astro';
import { SITE_DESCRIPTION, SITE_TITLE } from '../consts';
import { readFile } from 'fs/promises';
import { join } from 'path';

// Load turn history index from static files
const indexPath = join(process.cwd(), 'public', 'turn-history', 'index.json');
const indexContent = await readFile(indexPath, 'utf-8');
const runMetadata = JSON.parse(indexContent) as Array<{
	agent: string;
	seed: string;
	runId: string;
	outcome: string;
	turns: number[];
}>;

// Get unique agents and seeds
const agents = [...new Set(runMetadata.map(r => r.agent))].sort();
const seeds = [...new Set(runMetadata.map(r => r.seed))].sort();

// Create a map for quick lookup: agent -> seed -> outcome
const outcomeMap = new Map<string, Map<string, string>>();
for (const run of runMetadata) {
	if (!outcomeMap.has(run.agent)) {
		outcomeMap.set(run.agent, new Map());
	}
	outcomeMap.get(run.agent)!.set(run.seed, run.outcome);
}
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
		<style>
			main {
				max-width: 760px;
				margin: 0 auto;
				padding: 5rem 2rem;
			}
			
			.article-header {
				margin-bottom: 4rem;
				padding-bottom: 2rem;
				border-bottom: 1px solid var(--border-light);
			}
			
			.article-header h1 {
				margin-bottom: 1rem;
			}
			
			.article-subtitle {
				font-size: 1.25rem;
				color: var(--text-secondary);
				font-weight: 400;
				line-height: 1.6;
				font-family: 'Lora', Georgia, serif;
			}
			
		.article-content {
			line-height: 1.8;
		}
		
		.table-container {
			margin: 2rem 0;
			width: calc(100vw - 4rem);
			max-width: 1400px;
			position: relative;
			left: 50%;
			transform: translateX(-50%);
		}
		
		.outcomes-table {
			width: 100%;
			border-collapse: collapse;
			font-size: 0.9rem;
		}
		
		.outcomes-table th,
		.outcomes-table td {
			padding: 0.75rem;
			text-align: center;
			border: 1px solid var(--border-light);
		}
		
		.outcomes-table thead th {
			background-color: var(--bg-secondary);
			font-weight: 600;
			position: sticky;
			top: 0;
		}
		
		.outcomes-table tbody th {
			background-color: var(--bg-secondary);
			font-weight: 600;
			text-align: left;
		}
		
		.outcomes-table td.won {
			background-color: rgba(34, 197, 94, 0.1);
			color: rgb(34, 197, 94);
			font-weight: 600;
		}
		
		.outcomes-table td.lost {
			background-color: rgba(239, 68, 68, 0.1);
			color: rgb(239, 68, 68);
		}

		.turn-history-section {
			margin: 4rem 0;
			padding: 2rem;
			background-color: var(--bg-secondary);
			border-radius: 8px;
		}

		.turn-history-section h2 {
			margin-top: 0;
		}

		.selector-controls {
			display: flex;
			gap: 2rem;
			margin: 2rem 0;
			flex-wrap: wrap;
		}

		.control-group {
			display: flex;
			flex-direction: column;
			gap: 0.5rem;
		}

		.control-group label {
			font-weight: 600;
			font-size: 0.9rem;
		}

		.control-group select {
			padding: 0.5rem;
			border: 1px solid var(--border-light);
			border-radius: 4px;
			background-color: white;
			font-size: 1rem;
			min-width: 200px;
		}

		.turn-browser {
			margin-top: 2rem;
		}

		.turn-controls {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 2rem;
			padding: 1rem;
			background-color: white;
			border-radius: 4px;
		}

		.turn-controls button {
			padding: 0.75rem 1.5rem;
			background-color: var(--text-link);
			color: white;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 1rem;
			transition: opacity 0.2s ease;
		}

		.turn-controls button:hover:not(:disabled) {
			opacity: 0.9;
		}

		.turn-controls button:disabled {
			background-color: #ccc;
			cursor: not-allowed;
		}

		#turn-counter {
			font-weight: 600;
			font-size: 1.1rem;
		}

		.turn-display {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 2rem;
		}

		.turn-screenshot {
			background-color: white;
			padding: 1.5rem;
			border-radius: 4px;
		}

		.turn-screenshot h3 {
			margin-top: 0;
			margin-bottom: 1rem;
		}

		.turn-screenshot img {
			width: 100%;
			height: auto;
			border: 1px solid var(--border-light);
			border-radius: 4px;
		}

		.turn-details {
			display: flex;
			flex-direction: column;
			gap: 1.5rem;
		}

		.detail-section {
			background-color: white;
			padding: 1.5rem;
			border-radius: 4px;
		}

		.detail-section h3 {
			margin-top: 0;
			margin-bottom: 1rem;
		}

		.code-block {
			background-color: #f5f5f5;
			padding: 1rem;
			border-radius: 4px;
			overflow-x: auto;
			white-space: pre-wrap;
			word-wrap: break-word;
			font-family: 'Courier New', monospace;
			font-size: 0.85rem;
			line-height: 1.5;
			margin: 0;
		}
			
	.byline {
		font-size: 0.9rem;
		color: var(--text-secondary);
		margin-top: 0.5rem;
		display: flex;
		align-items: center;
		gap: 0.75rem;
	}
	
	.byline a {
		color: var(--text-link);
		text-decoration: none;
		border-bottom: 1px solid transparent;
		transition: border-color 0.2s ease;
		display: inline-flex;
		align-items: center;
		gap: 0.35rem;
	}
	
	.byline a:hover {
		border-bottom-color: var(--text-link);
	}
	
	.byline svg {
		width: 18px;
		height: 18px;
		fill: currentColor;
	}
		
		@media (max-width: 768px) {
			main {
				padding: 4rem 1.5rem;
			}
			
			.article-header {
				margin-bottom: 3rem;
			}
			
			.article-subtitle {
				font-size: 1.125rem;
			}
			
			.table-container {
				width: calc(100vw - 3rem);
				overflow-x: auto;
			}

			.turn-history-section {
				padding: 1.5rem;
			}

			.selector-controls {
				flex-direction: column;
				gap: 1rem;
			}

			.control-group select {
				min-width: 100%;
			}

			.turn-display {
				grid-template-columns: 1fr;
			}

			.turn-controls {
				flex-direction: column;
				gap: 1rem;
			}

			.turn-controls button {
				width: 100%;
			}
		}
		</style>
	</head>
	<body>
		<main>
			<header class="article-header">
				<h1>Can LLMs beat Balatro?</h1>
				<p class="article-subtitle">
					In short: yes, and now I'm betting on Google to win the AI race.
				</p>
			<p class="byline">
				<a href="https://www.linkedin.com/in/zhjzhang/" target="_blank" rel="noopener noreferrer">
					<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
						<path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
					</svg>
					Jordan Zhang
				</a>
				<span>•</span>
				<a href="https://github.com/zhzhang/llm-balatro/tree/main/experiment-code" target="_blank" rel="noopener noreferrer">
					<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
						<path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
					</svg>
					Code
				</a>
			</p>
			</header>
			
			<article class="article-content">
				<p>
					<strong>Balatro</strong> is a roguelike deckbuilder based on poker that was released in 2024.
					Players play poker hands to earn chips and pass rounds, trying to pass an exponentially increasing chip requirement as rounds progress.
					To keep up, players can gain power by buying Jokers and deck-modifying power ups that stack the deck in their favor.
				</p>
				<p>
					Balatro is a good test bed for LLM reasoning:
					- The game is stochastic with an enormous branching factor, requiring probabilistic reasoning to make optimal decisions.
					- Long sequences of planning and execution are needed to keep up with the exponentially increasing chip requirement.
					- The game is simple enough that its state can compactly be stringified, and the best move at any given time is usually path agnostic.

					Good Balatro play requires picking the best move at any state, while how that move may change the trajectory of the game dozens of turns down the line.
				</p>
			
				<div class="table-container">
					<table class="outcomes-table">
						<thead>
							<tr>
								<th>Agent</th>
								<th>22V4E3UE</th>
								<th>2JW2IH4X</th>
								<th>422J6NUH</th>
								<th>5U4K91D8</th>
								<th>84N5GIYF</th>
								<th>H1Z58VZ6</th>
								<th>M3F6LPGY</th>
								<th>M8KADSBQ</th>
								<th>PE93PR87</th>
								<th>U15QWQGE</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th>claude</th>
								<td class="lost">Ante 6</td>
								<td class="lost">Ante 6</td>
								<td class="lost">Ante 5</td>
								<td class="lost">Ante 6</td>
								<td class="lost">Ante 4</td>
								<td class="lost">Ante 5</td>
								<td class="lost">Ante 2</td>
								<td class="lost">Ante 5</td>
								<td class="lost">Ante 3</td>
								<td class="lost">Ante 4</td>
							</tr>
							<tr>
								<th>gemini</th>
								<td class="won">WON</td>
								<td class="won">WON</td>
								<td class="won">WON</td>
								<td class="won">WON</td>
								<td class="won">WON</td>
								<td class="won">WON</td>
								<td class="lost">Ante 4</td>
								<td class="won">WON</td>
								<td class="won">WON</td>
								<td class="won">WON</td>
							</tr>
							<tr>
								<th>openai</th>
								<td class="lost">Ante 5</td>
								<td class="lost">Ante 5</td>
								<td class="lost">Ante 7</td>
								<td class="lost">Ante 7</td>
								<td class="won">WON</td>
								<td class="lost">Ante 6</td>
								<td class="lost">Ante 4</td>
								<td class="lost">Ante 5</td>
								<td class="won">WON</td>
								<td class="won">WON</td>
							</tr>
						</tbody>
					</table>
				</div>

				<p>
					I think you'll notice the surprise here immediately: gemini-3-nano trounces both claude-4.5-sonnet and gpt-5.2, and this is despite going up against bigger and more expensive models.
				</p>

				<div class="turn-history-section">
					<h2>Explore Agent Turn History</h2>
					<p>Select an agent and seed to browse through the turn-by-turn gameplay.</p>
					
					<div class="selector-controls">
						<div class="control-group">
							<label for="agent-select">Agent:</label>
							<select id="agent-select">
								<option value="">-- Select Agent --</option>
								{agents.map(agent => (
									<option value={agent}>{agent}</option>
								))}
							</select>
						</div>
						
						<div class="control-group">
							<label for="seed-select">Seed:</label>
							<select id="seed-select">
								<option value="">-- Select Seed --</option>
								{seeds.map(seed => (
									<option value={seed}>{seed}</option>
								))}
							</select>
						</div>
					</div>

					<div id="turn-browser" class="turn-browser" style="display: none;">
						<div class="turn-controls">
							<button id="prev-turn" disabled>← Previous Turn</button>
							<span id="turn-counter">Turn 0 / 0</span>
							<button id="next-turn" disabled>Next Turn →</button>
						</div>

						<div class="turn-display">
							<div class="turn-screenshot">
								<h3>Game State Screenshot</h3>
								<img id="screenshot-img" alt="Game state screenshot" />
							</div>

							<div class="turn-details">
								<div class="detail-section">
									<h3>State Text</h3>
									<pre id="state-text" class="code-block"></pre>
								</div>

								<div class="detail-section">
									<h3>Agent Action</h3>
									<pre id="action-text" class="code-block"></pre>
								</div>

								<div class="detail-section">
									<h3>Agent Reasoning</h3>
									<pre id="reasoning-text" class="code-block"></pre>
								</div>
							</div>
						</div>
					</div>

					<div id="loading-message" style="display: none; text-align: center; padding: 2rem;">
						Loading turn history...
					</div>
				</div>

				<p>
					The reason for this gap, Google's greatest weapon in the current AI race: Youtube.
					When I originally started the agent development with Claude, performance was poor, and I looked for a textual guide to see if I could hand the manual strategy for success.
					(I also tried briefly implementing Reflexion, as well as an AlphaEvolve-based evolutionary algorithm)

					Good, comprehensive text-based guides were very hard to find, but Youtube had tons of content from streamers, breaking down strategies and gameplay.
					When watching gemini play, I noticed within the first couple of Antes that it knew more about the game than the other two models, certainly more than was possible from the state context I was giving it.
				</p>

				<p>
					See for yourself by stepping through the screenshots, state, and agent responses of each of the games below.
				</p>

				<p>
					Cost per playthrough.
				</p>

				<p>
					At the end of the day, the Bitter Lesson is that this AI race is about scaling compute and data, and teams that have access to more and better of both will win.

					This experiment has woken me up to how unfair of an advantage Youtube is in the AI race.

					The sheer amount of high fidelity multi-modal explanations of pretty much any topic you can imagine creates a data moat that companies starting from scraping the internet struggle to match.
				</p>
			</article>
		</main>

		<script>
			// Wait for DOM to be ready
			document.addEventListener('DOMContentLoaded', () => {
				let currentAgent = '';
				let currentSeed = '';
				let currentMetadata = null;
				let currentTurnIndex = 0;

				const agentSelect = document.getElementById('agent-select');
				const seedSelect = document.getElementById('seed-select');
				const turnBrowser = document.getElementById('turn-browser');
				const loadingMessage = document.getElementById('loading-message');
				const prevButton = document.getElementById('prev-turn');
				const nextButton = document.getElementById('next-turn');
				const turnCounter = document.getElementById('turn-counter');
				const screenshotImg = document.getElementById('screenshot-img');
				const stateText = document.getElementById('state-text');
				const actionText = document.getElementById('action-text');
				const reasoningText = document.getElementById('reasoning-text');

				async function loadTurnHistory() {
					const agent = agentSelect.value;
					const seed = seedSelect.value;

					if (!agent || !seed) {
						turnBrowser.style.display = 'none';
						return;
					}

					// Show loading
					turnBrowser.style.display = 'none';
					loadingMessage.style.display = 'block';

					try {
						// Load metadata for this agent/seed combination
						const metadataResponse = await fetch(`/turn-history/${agent}/${seed}/metadata.json`);
						if (!metadataResponse.ok) {
							throw new Error('Failed to fetch metadata');
						}

						currentMetadata = await metadataResponse.json();
						currentAgent = agent;
						currentSeed = seed;
						currentTurnIndex = 0;

						if (!currentMetadata.turns || currentMetadata.turns.length === 0) {
							alert('No turn history found for this game');
							loadingMessage.style.display = 'none';
							return;
						}

						// Show browser and display first turn
						loadingMessage.style.display = 'none';
						turnBrowser.style.display = 'block';
						await displayTurn();
					} catch (error) {
						console.error('Error loading turn history:', error);
						alert('Failed to load turn history. Check console for details.');
						loadingMessage.style.display = 'none';
					}
				}

				async function displayTurn() {
					if (!currentMetadata || !currentMetadata.turns.length) return;

					const turnNumber = currentMetadata.turns[currentTurnIndex];
					
					try {
						// Load turn data
						const turnResponse = await fetch(`/turn-history/${currentAgent}/${currentSeed}/${turnNumber}.json`);
						if (!turnResponse.ok) {
							throw new Error('Failed to fetch turn data');
						}
						const turnData = await turnResponse.json();
						
						// Update turn counter
						turnCounter.textContent = `Turn ${turnData.turn}${turnData.ante ? ` (Ante ${turnData.ante})` : ''} — ${currentTurnIndex + 1} / ${currentMetadata.turns.length}`;

						// Update screenshot
						if (turnData.hasScreenshot) {
							screenshotImg.src = `/turn-history/${currentAgent}/${currentSeed}/${turnNumber}.png`;
							screenshotImg.style.display = 'block';
						} else {
							screenshotImg.style.display = 'none';
						}

						// Update state text (prettify if it's JSON)
						if (turnData.state) {
							try {
								const stateObj = JSON.parse(turnData.state);
								stateText.textContent = JSON.stringify(stateObj, null, 2);
							} catch {
								stateText.textContent = turnData.state;
							}
						} else {
							stateText.textContent = 'No state data available';
						}

						// Update action text
						actionText.textContent = turnData.action || 'No action data available';

						// Update reasoning text
						reasoningText.textContent = turnData.reasoning || 'No reasoning data available';

						// Update button states
						prevButton.disabled = currentTurnIndex === 0;
						nextButton.disabled = currentTurnIndex === currentMetadata.turns.length - 1;
					} catch (error) {
						console.error('Error displaying turn:', error);
						alert('Failed to load turn data');
					}
				}

				async function goToPreviousTurn() {
					if (currentTurnIndex > 0) {
						currentTurnIndex--;
						await displayTurn();
					}
				}

				async function goToNextTurn() {
					if (currentMetadata && currentTurnIndex < currentMetadata.turns.length - 1) {
						currentTurnIndex++;
						await displayTurn();
					}
				}

				// Event listeners
				agentSelect.addEventListener('change', loadTurnHistory);
				seedSelect.addEventListener('change', loadTurnHistory);
				prevButton.addEventListener('click', goToPreviousTurn);
				nextButton.addEventListener('click', goToNextTurn);

				// Keyboard navigation
				document.addEventListener('keydown', (e) => {
					if (turnBrowser.style.display === 'none') return;
					
					if (e.key === 'ArrowLeft') {
						goToPreviousTurn();
					} else if (e.key === 'ArrowRight') {
						goToNextTurn();
					}
				});
			});
		</script>
	</body>
</html>
